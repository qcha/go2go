# Append Slices

## Условие

Что выведен на экран следующая программа и почему?

```go
package main

func main() {
    a1 := make([]int, 0, 10)
    a1 = append(a1, []int{1, 2, 3, 4, 5}...)
    a2 := append(a1, 6)
    a3 := append(a1, 7)

    fmt.Println(a1, a2, a3)
}
```

## Решение

Давайте по строчно разберем то, что происходит в программе:

```go
package main

func main() {
    a1 := make([]int, 0, 10) // создается слайс int-ов, len = 0, cap = 10
    a1 = append(a1, []int{1, 2, 3, 4, 5}...) // len = 5, cap = 10,  new struct // 1 2 3 4 5
    a2 := append(a1, 6) // len = 6, cap = 10, new struct // 1 2 3 4 5 6
    a3 := append(a1, 7) // len = 6, cap = 10, new struct // 1 2 3 4 5 7

    fmt.Println(a1, a2, a3)
}
```

Разберем по шагам:

1. a1 := make([]int, 0, 10)

    Создаёт слайс с длиной 0, вместимостью 10

    a1: [] - пустой слайс, но заранее зарезервировано 10 ячеек (len = 0, а cap = 10)

2. a1 = append(a1, []int{1, 2, 3, 4, 5}...)

    Добавляем 5 чисел: a1 теперь []int{1, 2, 3, 4, 5}

    Длина 5, вместимость 10 (len = 5, а cap = 10)

    Память не перераспределяется, a1 опирается на тот же массив

3. a2 := append(a1, 6)

    a1 имел cap=10, len=5, значит в него можно добавить ещё 5 элементов без перераспределения

    Добавляется 6, результат: []int{1, 2, 3, 4, 5, 6}

    Длина 6, вместимость 10 (len = 6, а cap = 10)

    Важно помнить, что a2 использует ту же память, что и a1, просто слайс длиннее

4. a3 := append(a1, 7)

    Добавляем 7, результат: []int{1, 2, 3, 4, 5, 7}

    Но a2 и a3 делят одну и ту же память с a1.

    Поэтому, значение 6, добавленное в a2, перезатирается новым элементом - это 7-ка!

    Длина остается 6, вместимость 10 (len = 6, а cap = 10)

Функция fmt.Println учитывает длину слайса, поэтому:

```text
[1 2 3 4 5] [1 2 3 4 5 7] [1 2 3 4 5 7]
```
