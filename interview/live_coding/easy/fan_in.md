# Fan-In

## Условие

Реализуйт паттерн Fan-In: напишите функцию для объединения данных из нескольких каналов в один выходной канал.

## Решение

Нашу функцию сделаем generic, чтоб можно было объединять каналы любого типа.

Важно чтение из каналов осуществлять в отдельных горутинах, чтобы избежать блокировки.
Например, в ситуации, когда из какого-то канала будет нечего читать.

Результирующий канал закрывать будем только после завершения всех тех, откуда читаем — это делается с помощью `sync.WaitGroup`.

Обязательно надо проверить на то, что `ch` не `nil`, иначе чтение из `nil` канала повесит горутину навсегда.

Также важно при обходе слайса, `ch` передавать в горутину (делать локальную копию текущего значения ch из цикла):

```go
    for _, ch := range channels {
        if ch == nil {
            continue
        }

        go func(c <-chan T) {
            // do smth
        }(ch)
    }
```

Если в горутине использовать переменную из внешнего цикла, не передавая её явно в `func(ch)`, то произойдет захват переменной по ссылке (closure capture).

Это может привести к тому, что все горутины могут начать использовать одно и то же последнее значение переменной ch, потому что ch меняется в цикле, а горутины стартуют асинхронно.

Результат: одна из горутин может читать не из своего канала, а из другого (или `nil`, если в конце был `nil`-канал).

Итого:

```go
func fanIn[T any](channels []<-chan T) <-chan T {
    out := make(chan T)
    var wg sync.WaitGroup

    for _, ch := range channels {
        if ch == nil {
            continue
        }

        wg.Add(1)
        go func(c <-chan T) {
            defer wg.Done()
            for v := range c {
                out <- v
            }
        }(ch)
    }

    go func() {
        wg.Wait()
        close(out)
    }()

    return out
}
```

Проверяем:

```go
func main() {
    ch1 := make(chan string)
    ch2 := make(chan string)

    // Пишем в каналы
    go func() {
        ch1 <- "one"
        ch1 <- "two"
        close(ch1)
    }()
    go func() {
        ch2 <- "three"
        ch2 <- "four"
        close(ch2)
    }()

    // Объединяем каналы
    out := fanIn([]<-chan string{ch1, ch2})

    // Читаем всё из объединённого канала
    for msg := range out {
        fmt.Println(msg)
    }
}
```
